<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/blog2_32x32.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/blog2_16x16.ico">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.stolenzc.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《Python 工匠》读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《Python 工匠》读书笔记">
<meta property="og:url" content="https://blog.stolenzc.com/2023/python_artisan/index.html">
<meta property="og:site_name" content="stolen&#39;s blog">
<meta property="og:description" content="《Python 工匠》读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-04-11T04:22:42.000Z">
<meta property="article:modified_time" content="2023-04-11T04:22:42.000Z">
<meta property="article:author" content="stolen">
<meta property="article:tag" content="操作使用">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.stolenzc.com/2023/python_artisan/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《Python 工匠》读书笔记 | stolen's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">stolen's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">逆风的方向，更适合飞翔</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-首页">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-标签">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-分类">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-归档">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-关于">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.stolenzc.com/2023/python_artisan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="stolen">
      <meta itemprop="description" content="一个热爱技术的Python开发者">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="stolen's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《Python 工匠》读书笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 12:22:42" itemprop="dateCreated datePublished" datetime="2023-04-11T12:22:42+08:00">2023-04-11</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
          <!--<br>-->
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.2k</span>
            </span>
            <div class="post-description">《Python 工匠》读书笔记</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="变量与注释"><a href="#变量与注释" class="headerlink" title="变量与注释"></a>变量与注释</h2><p>变量命名原则</p>
<ol>
<li>遵循 PEP8 规范</li>
<li>描述性要强（结合场景尽可能详尽的描述变量）</li>
<li>尽量短（为变量命名要结合情景和上下文）</li>
<li>要匹配类型<ul>
<li>bool (is_, has_, allow_)</li>
<li>int/float<ul>
<li>含义为数字的单词：port, age, radius</li>
<li>以 _id 结尾的变量：user_id, product_id</li>
<li>以 length/count 开头或结尾的单词，users_count, length_of_name</li>
<li>慎用名词复数表示 int 变量，users 容易误解为 List[User]</li>
</ul>
</li>
<li>其他类型的变量建议使用明确的类型注解来标注类型</li>
</ul>
</li>
<li>超短命名结合场景使用和避免<ul>
<li>数组索引三剑客 i, j, k</li>
<li>某个整数 n</li>
<li>某个字符串 s</li>
<li>某个异常 e</li>
<li>文件对象 fp</li>
</ul>
</li>
</ol>
<p>变量和注释使用原则</p>
<ol>
<li>保持变量的一致性<ul>
<li>名字一致性：在同一个项目、模块中，对一类事物的称呼要保持一致</li>
<li>类型一致性：同一个变量不要重复指向不同的类型</li>
</ul>
</li>
<li>变量类型定义尽量靠近使用：C 语言后遗症；靠近使用能够把一条逻辑完整的串在一起，不必来回翻阅</li>
<li>定义临时变量提升代码可读性：例如过长的 if 条件，会使读者头痛</li>
<li>同一作用域内不要有太多变量：变量太多会导致读者难以理解，建议拆分函数</li>
<li>能不定义变量就别定义：例如将计算结果放入列表，而不是先定义变量，再将变量放入列表</li>
<li>不要使用 locals()：容易暴露没有真正使用的变量</li>
<li>空行也是一种注释：空行可以将代码分组，提升可读性</li>
<li>先写注释后写代码：先写注释可以帮助思考，也可以帮助后续的代码阅读者理解代码</li>
</ol>
<h2 id="数值与字符串"><a href="#数值与字符串" class="headerlink" title="数值与字符串"></a>数值与字符串</h2><p>数值使用</p>
<ul>
<li>Python的浮点数有精度问题，请使用Decimal对象做精确的小数运算</li>
<li>布尔类型是整型的子类型，布尔值可以当作0和1来使用</li>
<li>使用 <code>float(&#39;inf&#39;)</code> 无穷大可以简化边界处理逻辑</li>
</ul>
<p>字符串使用</p>
<ul>
<li>字符串分为两类：str（给人阅读的文本类型）和bytes（给计算机阅读的二进制类型）</li>
<li>通过 <code>str.encode()</code> 与 <code>byte.decode()</code> 可以在两种字符串之间做转换</li>
<li>优先推荐的字符串格式化方式（从前往后）： <code>f-string</code>、<code>str.format()</code>、<code>C语言风格格式化(%)</code></li>
<li>使用以r开头的字符串内置方法可以从右往左处理字符串，特定场景下可以派上用场</li>
</ul>
<p>代码可读性</p>
<ul>
<li>在定义数值字面量时，可以通过插入_字符来提升可读性</li>
<li>不要出现“神奇”的字面量，使用常量或者枚举类型替换它们</li>
<li>保留数学算式表达式不会影响性能，并且可以提升可读性</li>
<li>使用 <code>textwrap.dedent()</code> 可以让多行字符串更好地融入代码</li>
</ul>
<p>代码可维护性</p>
<ul>
<li>当操作SQL语句等结构化字符串时，使用专有模块比裸处理的代码更易于维护</li>
<li>使用 <code>Jinja2</code> 模板来替代字符串拼接操作</li>
</ul>
<p>语言内部</p>
<ul>
<li>对于从 -5 到 256 的这些常用小整数， Python 会将它们缓存在内存里的一个数组中。当你的程序需要用到这些数字时， Python 不会创建任何新的整型对象，而是会返回缓存中的对象。这样能为程序节约可观的内存</li>
<li>使用dis模块可以查看Python字节码，帮助我们理解内部原理</li>
<li>使用 <code>timeit</code> 模块可以对Python代码方便地进行性能测试</li>
<li>Python语言进化得很快，不要轻易被旧版本的“经验”所左右</li>
</ul>
<h2 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h2><p>基础知识</p>
<ul>
<li>在进行函数调用时，传递的不是变量的值或者引用，而是变量所指对象的引用</li>
<li>Python 内置类型分为可变与不可变两种，可变性会影响一些操作的行为，比如 <code>+=</code></li>
<li>对于可变类型，必要时对其进行拷贝操作，能避免产生意料之外的影响</li>
<li>常见的浅拷贝方式：<code>copy.copy</code>、推导式、切片操作</li>
<li>使用 <code>copy.deepcopy</code> 可以进行深拷贝操作</li>
</ul>
<p>列表与元组</p>
<ul>
<li>使用 <code>enumerate</code> 可以在遍历列表的同时获取下标</li>
<li>函数的多返回值其实是一个元组</li>
<li>不存在元组推导式，但可以使用tuple来将生成器表达式转换为元组</li>
<li>元组经常用来表示一些结构化的数据</li>
</ul>
<p>字典与集合</p>
<ul>
<li>在Python 3.7版本前，字典类型是无序的，之后变为保留数据的插入顺序</li>
<li>使用 <code>OrderedDict</code> 可以在 Python 3.7 以前的版本里获得有序字典</li>
<li>只有可哈希的对象才能存入集合，或者作为字典的键使用</li>
<li>使用有序字典 <code>OrderedDict</code> 可以快速实现有序去重</li>
<li>使用 <code>fronzenset</code> 可以获得一个不可变的集合对象</li>
<li>集合可以方便地进行集合运算，计算交集、并集</li>
<li>不要通过继承 <code>dict</code> 来创建自定义字典类型</li>
</ul>
<p>代码可读性技巧</p>
<ul>
<li>具名元组比普通元组可读性更强</li>
<li>列表推导式可以更快速地完成遍历、过滤、处理以及构建新列表操作</li>
<li>不要编写过于复杂的推导式，用朴实的代码替代就好</li>
<li>不要把推导式当作代码量更少的循环，写普通循环就好</li>
</ul>
<p>代码可维护性技巧</p>
<ul>
<li>当访问的字典键不存在时，可以选择捕获异常或先做判断，优先推荐捕获异常</li>
<li>使用 <code>get</code> 、 <code>setdefault</code> 、<code>带参数的pop方法</code> 可以简化边界处理逻辑</li>
<li>使用具名元组作为返回值，比普通元组更好扩展</li>
<li>当字典键不存在时，使用 <code>defaultdict</code> 可以简化处理</li>
<li>继承 <code>MutableMapping</code> 可以方便地创建自定义字典类，封装处理逻辑(如果直接继承 <code>dict</code> ，当重写 <code>__setitem__</code> 时，直接赋值可以出发该函数，但 <code>update</code> 无法触发该操作，继承 <code>MutableMapping</code> 可以解决这个问题，自定义其他容器也会存在类似问题)</li>
<li>用生成器按需返回成员，比直接返回一个结果列表更灵活，也更省内存</li>
<li>使用动态解包语法可以方便地合并字典</li>
<li>不要在遍历列表的同时修改，否则会出现不可预期的结果</li>
</ul>
<p>代码性能要点</p>
<ul>
<li>列表的底层实现决定了它的头部操作很慢， <code>deque</code> 类型则没有这个问题</li>
<li>当需要判断某个成员在容器中是否存在时，使用字典/集合更快</li>
</ul>
<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 具名元组</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Rectangle = namedtuple(<span class="string">'Rectangle'</span>, <span class="string">'width,height'</span>)</span><br><span class="line">rect = Rectangle(width=<span class="number">100</span>, height=<span class="number">200</span>)</span><br><span class="line">rect.width  <span class="comment"># 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.6 语法</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle2</span><span class="params">(NamedTuple)</span>:</span></span><br><span class="line">    width: int</span><br><span class="line">    height: int</span><br><span class="line">rect = Rectangle2(<span class="number">100</span>, <span class="number">200</span>)</span><br><span class="line">rect.width  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字典的 setdefault 方法</span></span><br><span class="line">d = &#123;<span class="string">'title'</span>: <span class="string">'foobar'</span>&#125;</span><br><span class="line">d.setdefault(<span class="string">'items'</span>, []).append(<span class="string">'foo'</span>)</span><br><span class="line">print(d)  <span class="comment"># &#123;'title': 'foobar', 'items': ['foo']&#125;</span></span><br><span class="line">d.setdefault(<span class="string">'items'</span>, []).append(<span class="string">'bar'</span>)</span><br><span class="line">print(d)  <span class="comment"># &#123;'title': 'foobar', 'items': ['foo', 'bar']&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OrderedDict</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">d1 = &#123;<span class="string">'name'</span>: <span class="string">'piglei'</span>, <span class="string">'fruit'</span>: <span class="string">'apple'</span>&#125;</span><br><span class="line">d2 = &#123;<span class="string">'fruit'</span>: <span class="string">'apple'</span>, <span class="string">'name'</span>: <span class="string">'piglei'</span>&#125;</span><br><span class="line">d1 == d2  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">d1 = OrderedDict(name=<span class="string">'piglei'</span>, fruit=<span class="string">'apple'</span>)</span><br><span class="line">d2 = OrderedDict(fruit=<span class="string">'apple'</span>, name=<span class="string">'piglei'</span>)</span><br><span class="line">d1 == d2  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 OrderedDict 可以实现有序去重</span></span><br><span class="line">nums = [<span class="number">10</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">2</span>]</span><br><span class="line">set(nums)  <span class="comment"># &#123;2, 3, 10, 21&#125;</span></span><br><span class="line">list(OrderedDict.fromkeys(nums))  <span class="comment"># [10, 2, 3, 21]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># frozenset</span></span><br><span class="line"><span class="comment"># frozenset 是一个内置的类型，不需要导入</span></span><br><span class="line">f_set = frozenset([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># deque，当用列表向头插入输入数据时，会存在性能问题，使用 deque 可以解决这个问题</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">　</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deque_append</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""不断往尾部追加"""</span></span><br><span class="line">    l = deque()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5000</span>):</span><br><span class="line">        l.append(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deque_appendleft</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""不断往头部插入"""</span></span><br><span class="line">    l = deque()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5000</span>):</span><br><span class="line">        l.appendleft(i)</span><br></pre></td></tr></table></figure>

<h2 id="分之流程控制"><a href="#分之流程控制" class="headerlink" title="分之流程控制"></a>分之流程控制</h2><p>条件分支语句</p>
<ul>
<li>不要显式地和布尔值做比较</li>
<li>利用类型本身的布尔值规则，省略零值判断</li>
<li>把not代表的否定逻辑移入表达式内部</li>
<li>仅在需要判断某个对象是否是None、True、False时，使用is运算符</li>
</ul>
<p>Python数据模型</p>
<ul>
<li>定义 <code>__len__</code> 和 <code>__bool__</code> 魔法方法，可以自定义对象的布尔值规则</li>
<li>定义 <code>__eq__</code> 方法，可以修改对象在进行 <code>==</code> 运算时的行为</li>
</ul>
<p>代码可读性技巧</p>
<ul>
<li>不同分支内容易出现重复或类似的代码，把它们抽到分支外可提升代码的可读性</li>
<li>使用“德摩根定律”可以让有多重否定的表达式变得更容易理解<ul>
<li>德摩根定律 - <code>not A or not B</code> 等价于 <code>not (A and B)</code></li>
</ul>
</li>
</ul>
<p>代码可维护性技巧</p>
<ul>
<li>尽可能让三元表达式保持简单</li>
<li>扁平优于嵌套：使用“提前返回”优化代码里的多层分支嵌套</li>
<li>当条件表达式变得特别复杂时，可以尝试封装新的函数和方法来简化</li>
<li>and的优先级比or高，不要忘记使用括号来让逻辑更清晰</li>
<li>在使用or运算符替代条件分支时，请注意避开因布尔值运算导致的陷阱</li>
</ul>
<p>代码组织技巧</p>
<ul>
<li><code>bisect</code> 模块可以用来优化范围类分支判断</li>
<li>字典类型可以用来替代简单的条件分支语句</li>
<li>尝试总结条件分支代码里的规律，用更精简、更易扩展的方式改写它们</li>
<li>使用 <code>any()</code> 和 <code>all()</code> 内置函数可以让条件表达式变得更精简</li>
</ul>
<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"><span class="comment"># 注意：用来做二分查找的容器必须是已经排好序的</span></span><br><span class="line">breakpoints = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="comment"># bisect 函数会返回值在列表中的位置，0 代表相应的值位于第一个元素 10 之前</span></span><br><span class="line">bisect.bisect(breakpoints, <span class="number">1</span>)  <span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 3 代表相应的值位于第三个元素 30 之后</span></span><br><span class="line">bisect.bisect(breakpoints, <span class="number">35</span>)  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h2 id="异常与错误处理"><a href="#异常与错误处理" class="headerlink" title="异常与错误处理"></a>异常与错误处理</h2><p>基础知识</p>
<ul>
<li>一个 try 语句支持多个 except 子句，但请记得把更精确的异常类放在前面</li>
<li>try 语句的 else 分支会在没有异常时执行，因此它可用来替代标记变量</li>
<li>不带任何参数的 raise 语句会重复抛出当前异常</li>
<li>上下文管理器经常用来处理异常，它最常见的用途是替代 finally 子句</li>
<li>上下文管理器可以用来忽略某段代码里的异常</li>
<li>使用 <code>@contextmanager</code> 装饰器可以轻松定义上下文管理器</li>
<li>和许多其他编程语言不同，在Python里抛出和捕获异常是很轻量的操作，即使大量抛出、捕获异常，也不会给程序带来过多额外负担。</li>
</ul>
<p>错误处理与参数校验</p>
<ul>
<li>当你可以选择编写条件判断或异常捕获时，优先选异常捕获（EAFP）<ul>
<li>EAFP（easier to ask for forgiveness than permission），可直译为“获取原谅比许可简单”</li>
</ul>
</li>
<li>不要让函数返回错误信息，直接抛出自定义异常吧</li>
<li>手动校验数据合法性非常烦琐，尽量使用专业模块来做这件事</li>
<li>不要使用 assert 来做参数校验，用 raise 替代它<ul>
<li>assert 是一个专供开发者调试程序的关键字。它所提供的断言检查，可以在执行 Python 时使用 -O 选项直接跳过</li>
</ul>
</li>
<li>处理错误需要付出额外成本，假如能通过设计避免它就再好不过了</li>
<li>在设计 API 时，需要慎重考虑是否真的有必要抛出错误</li>
<li>使用“空对象模式”能免去一些针对边界情况的错误处理工作</li>
</ul>
<p>捕获异常时</p>
<ul>
<li>过于模糊和宽泛的异常捕获可能会让程序免于崩溃，但也可能会带来更大的麻烦</li>
<li>异常捕获贵在精确，只捕获可能抛出异常的语句，只捕获可能的异常类型</li>
<li>有时候，让程序提早崩溃未必是什么坏事</li>
<li>完全忽略异常是风险非常高的行为，大多数情况下，至少记录一条错误日志</li>
</ul>
<p>抛出异常时</p>
<ul>
<li>保证模块内抛出的异常与模块自身的抽象级别一致</li>
<li>如果异常的抽象级别过高，把它替换为更低级的新异常</li>
<li>如果异常的抽象级别过低，把它包装成更高级的异常，然后重新抛出</li>
<li>不要让调用方用字符串匹配来判断异常种类，尽量提供可区分的异常</li>
</ul>
<p>代码示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_conn_obj</span><span class="params">(host, port, timeout=None)</span>:</span></span><br><span class="line">    <span class="string">"""创建连接对象，并在退出上下文时自动关闭"""</span></span><br><span class="line">    conn = create_conn(host, port, timeout=timeout)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br></pre></td></tr></table></figure>

<h2 id="循环与可迭代对象"><a href="#循环与可迭代对象" class="headerlink" title="循环与可迭代对象"></a>循环与可迭代对象</h2><p>迭代与迭代器原理</p>
<ul>
<li>使用 <code>iter()</code> 函数会尝试获取一个迭代器对象</li>
<li>使用 <code>next()</code> 函数会获取迭代器的下一个内容</li>
<li>可以将for循环简单地理解为 while 循环+不断调用 <code>next()</code></li>
<li>自定义迭代器需要实现 <code>__iter__</code> 和 <code>__next__</code> 两个魔法方法</li>
<li>生成器对象是迭代器的一种</li>
<li><code>iter(callable, sentinel)</code> 可以基于可调用对象构造一个迭代器</li>
</ul>
<p>迭代器与可迭代对象</p>
<ul>
<li>迭代器和可迭代对象是不同的概念</li>
<li>可迭代对象不一定是迭代器，但迭代器一定是可迭代对象</li>
<li>对可迭代对象使用 <code>iter()</code> 会返回迭代器，迭代器则会返回它自身</li>
<li>每个迭代器的被迭代过程是一次性的，可迭代对象则不一定</li>
<li>可迭代对象只需要实现 <code>__iter__</code> 方法，而迭代器要额外实现 <code>__next__</code> 方法</li>
</ul>
<p>代码可维护性技巧</p>
<ul>
<li>通过定义生成器函数来修饰可迭代对象，可以优化循环内部代码</li>
<li><code>itertools</code> 模块里有许多函数可以用来修饰可迭代对象</li>
<li>生成器函数可以用来解耦循环代码，提升可复用性</li>
<li>不要使用多个 <code>break</code> ，拆分为函数然后直接 <code>return</code> 更好</li>
<li>使用 <code>next()</code> 函数有时可以完成一些意想不到的功能</li>
</ul>
<p>文件操作知识</p>
<ul>
<li>使用标准做法读取文件内容，在处理没有换行符的大文件时会很慢</li>
<li>调用 <code>file.read()</code> 方法可以解决读取大文件的性能问题</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数参数与返回相关基础知识</p>
<ul>
<li>不要使用可变类型作为参数默认值，用None来代替</li>
<li>通过 <code>__defaults__</code> 属性可以直接获取函数的参数默认值</li>
<li>用 <code>object()</code> 来做可能传入 <code>None</code> 的函数默认值</li>
<li>使用标记对象，可以严格区分函数调用时是否提供了某个参数</li>
<li>定义仅限关键字参数，可以强制要求调用方提供参数名，提升可读性</li>
<li>函数应该拥有稳定的返回类型，不要返回多种类型</li>
<li>适合返回None的情况——操作类函数、查询类函数表示意料之中的缺失值</li>
<li>在执行失败时，相比返回None，抛出异常更为合适</li>
<li>如果提前返回结果可以提升可读性，就提前返回，不必追求“单一出口”</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">append_value</span><span class="params">(value, items=[])</span>:</span></span><br><span class="line">    <span class="string">"""向 items 列表中追加内容，并返回列表"""</span></span><br><span class="line">    items.append(value)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: append_value.__defaults__</span><br><span class="line">Out[<span class="number">2</span>]: ([],)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义标记变量</span></span><br><span class="line"><span class="comment"># object 通常不会单独使用，但是拿来做这种标记变量刚刚好</span></span><br><span class="line">_not_set = object()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump_value</span><span class="params">(value, extra=_not_set)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> extra <span class="keyword">is</span> _not_set:</span><br><span class="line">        <span class="comment"># 调用方没有传递 extra 参数</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>代码可维护性技巧</p>
<ul>
<li>不要编写太长的函数，但长度并没有标准，65行算是一个危险信号</li>
<li>圈复杂度是评估函数复杂程度的常用指标，圈复杂度超过10的函数需要重构</li>
<li>抽象与分层思想可以帮我们更好地构建与管理复杂的系统</li>
<li>同一个函数内的代码应该处在同一抽象级别</li>
</ul>
<p>函数与状态</p>
<ul>
<li>没有副作用的无状态纯函数易于理解，容易维护，但大多数时候“状态”不可避免</li>
<li>避免使用全局变量给函数增加状态</li>
<li>当函数状态较简单时，可以使用闭包技巧</li>
<li>当函数需要较为复杂的状态管理时，建议定义类来管理状态</li>
</ul>
<p>语言机制对函数的影响</p>
<ul>
<li><code>functools.partial()</code> 可以用来快速构建偏函数</li>
<li><code>functools.lru_cache()</code> 可以用来给函数添加缓存</li>
<li>比起 <code>map</code> 和 <code>filter</code> ，列表推导式的可读性更强，更应该使用</li>
<li><code>lambda</code> 函数只是一种语法糖，你可以使用 <code>operator</code> 模块等方式来替代它</li>
<li>Python 语言里的递归限制较多，可能的话，请尽量使用循环来替代</li>
</ul>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>基础与技巧</p>
<ul>
<li>装饰器最常见的实现方式，是利用闭包原理通过多层嵌套函数实现</li>
<li>在实现装饰器时，请记得使用 <code>wraps()</code> 更新包装函数的元数据，添加 <code>@wraps(wrapped)</code> 来装饰 decorated 函数后，<code>wraps()</code> 首先会基于原函数 func 来更新包装函数 decorated 的名称、文档等内置属性，之后会将 func 的所有额外属性赋值到 decorated 上</li>
<li><code>wraps()</code> 不光可以保留元数据，还能保留包装函数的额外属性</li>
<li>利用仅限关键字参数，可以很方便地实现可选参数的装饰器</li>
</ul>
<p>使用类来实现装饰器</p>
<ul>
<li>只要是可调用的对象，都可以用作装饰器</li>
<li>实现了<strong>call</strong>方法的类实例可调用</li>
<li>基于类的装饰器分为两种：“函数替换”与“实例替换”</li>
<li>“函数替换”装饰器与普通装饰器没什么区别，只是嵌套层级更少</li>
<li>通过类来实现“实例替换”装饰器，在管理状态和追加行为上有天然的优势</li>
<li>混合使用类和函数来实现装饰器，可以灵活满足各种场景</li>
</ul>
<p>使用wrapt模块</p>
<ul>
<li>使用wrapt模块可以方便地让装饰器同时兼容函数和类方法</li>
<li>使用wrapt模块可以帮你写出结构更扁平的装饰器代码</li>
</ul>
<p>装饰器设计技巧</p>
<ul>
<li>装饰器将包装调用提前到了函数被定义的位置，它的大部分优点也源于此</li>
<li>在编写装饰器时，请考虑你的设计是否能很好发挥装饰器的优势</li>
<li>在某些场景下，类装饰器可以替代元类，并且代码更简单</li>
<li>装饰器和装饰器模式截然不同，不要弄混它们</li>
<li>装饰器里应该只有一层浅浅的包装代码，要把核心逻辑放在其他函数与类中</li>
</ul>
<h2 id="附录1-内置语法特性"><a href="#附录1-内置语法特性" class="headerlink" title="附录1-内置语法特性"></a>附录1-内置语法特性</h2><ul>
<li><p><code>locals()</code> - 返回当前作用域内的所有局部变量</p>
</li>
<li><p>Python 的浮点数是使用符合 IEEE-754 规范的双精度，使用 53 个比特精度来表示十进制浮点数</p>
</li>
<li><p><code>str.partition(sep)</code> - 从左往右查找第一个 sep 出现的位置，返回一个三元组，包含分割前的字符串、sep、分割后的字符串</p>
</li>
<li><p><code>str.translate(table)</code> - 使用 table 中的映射关系来替换字符串中的字符</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'明明是中文,却使用了英文标点.'</span></span><br><span class="line"><span class="comment"># 创建替换规则表：',' -&gt; '，', '.' -&gt; '。'</span></span><br><span class="line">table = s.maketrans(<span class="string">',.'</span>, <span class="string">'，。'</span>)</span><br><span class="line">s.translate(table)</span><br><span class="line"><span class="comment"># '明明是中文，却使用了英文标点。'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>enmuerate(iterable, start=0)</code> - 返回一个枚举对象，包含每个元素的索引值与元素值</p>
<ul>
<li><code>start</code> - 索引起始值，默认为0</li>
</ul>
</li>
<li><p><code>frozenset</code> - 不可变集合，不支持添加、删除操作，比起 set 没有以下方法</p>
<ul>
<li><code>add</code></li>
<li><code>clear</code></li>
<li><code>discard</code></li>
<li><code>pop</code></li>
<li><code>remove</code></li>
<li><code>update</code></li>
<li><code>|=</code> / <code>&amp;=</code> / <code>-=</code> / <code>^=</code></li>
</ul>
</li>
<li><p><code>if</code> 语句后直接放自定义类型，会优先查找 <code>__bool__</code> 的定义，如果没有再查找 <code>__len__</code> 的定义，如果都没有，会返回 True</p>
</li>
<li><p>Python 中 <code>True</code> / <code>False</code> / <code>None</code> 是严格以单例模式实现的，可以使用 <code>is</code> 来判断两个变量是否指向同一个对象</p>
</li>
<li><p><code>all(iterable)</code> - 仅当iterable中所有成员的布尔值都为真时返回True，否则返回False</p>
</li>
<li><p><code>any(iterable)</code> - 只要iterable中任何一个成员的布尔值为真就返回True，否则返回False</p>
</li>
<li><p><code>with</code> 语句会在代码块执行前调用 <code>__enter__</code> 方法，执行后调用 <code>__exit__</code> 方法，使用 with 语句的对象必须实现这两个方法，这两个方法都可以返回一个值，如果 <code>__exit__</code> 返回 True，异常会被忽略，否则异常会被重新抛出</p>
<ul>
<li><code>__exit__</code> 接受三个参数，exc_type / exc_val / exc_tb，分别表示异常类型、异常对象、异常堆栈信息</li>
<li><code>__exit__</code> 返回 True 时，异常会被忽略，返回 False 时，异常会被重新抛出</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ignore_close</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_type == CloseError:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当你使用 <code>for</code> 循环遍历某个可迭代对象时，其实是先调用了 <code>iter()</code> 拿到它的迭代器，然后不断地用 <code>next()</code> 从迭代器中获取值</p>
</li>
<li><p>如果一个类型没有定义 <code>__iter__</code> ，但是定义了 <code>__getitem__</code> 方法，那么 Python 也会认为它是可迭代的。在遍历它时，解释器会不断使用数字索引值(0, 1, 2, …)来调用 <code>__getitem__</code> 方法获得返回值，直到抛出 <code>IndexError</code> 为止。</p>
</li>
</ul>
<h2 id="附录2-内置库功能"><a href="#附录2-内置库功能" class="headerlink" title="附录2-内置库功能"></a>附录2-内置库功能</h2><ul>
<li><p><code>timeit.timeit(setup, setup, timer, number)</code> - 测试代码执行时间</p>
<ul>
<li><code>stmt</code> - 这将采用您要测量其执行时间的代码。默认值为 <code>pass</code></li>
<li><code>setup</code> - 这将包含需要在stmt之前执行的设置详细信息。默认值为 <code>pass</code></li>
<li><code>timer</code> - 它将具有计时器值，<code>timeit()</code> 已经设置了默认值，我们可以忽略它</li>
<li><code>number</code> - <code>stmt</code> 将按照此处给出的编号执行多少次。默认值为1000000</li>
</ul>
</li>
<li><p><code>textwrap.dedent(text)</code> - dedent方法会删除整段字符串左侧的空白缩进。使整段代码的缩进视觉效果保持正常</p>
</li>
<li><p><code>collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)</code> - 创建一个具名元组子类</p>
<ul>
<li><code>typename</code> - 元组名称</li>
<li><code>field_names</code> - 元组字段名称，可以是字符串列表、空格分隔的字符串、逗号分割的字符串</li>
<li><code>rename</code> - 如果字段名称中有 Python 关键字，需要设置为 <code>True</code>，默认为 <code>False</code></li>
<li><code>defaults</code> - 字段的默认值，可以是一个列表或者是一个字典</li>
<li><code>module</code> - 指定元组所在的模块名称</li>
</ul>
</li>
<li><p><code>bisect.bisect(a, x)</code> - 在有序序列 a 中查找 x 的插入位置，返回插入位置的索引值</p>
</li>
<li><p><code>bisect.insort(a, x)</code> - 在有序序列 a 中插入 x，返回插入位置的索引值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> bisect, insort</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="number">20</span>]</span><br><span class="line">bisect(a, <span class="number">7</span>)  <span class="comment"># 3</span></span><br><span class="line">insort(a, <span class="number">7</span>)  <span class="comment"># [1, 4, 6, 7, 8, 12, 15, 20]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>itertools.product(*iterables, repeat=1)</code> - 接受多个可迭代对象，返回计算笛卡尔积</p>
</li>
<li><p><code>itertools.islice(iterable, start, stop[, step])</code> - 返回一个迭代器，从 <code>start</code> 开始，到 <code>stop</code> 结束，步长为 <code>step</code></p>
</li>
</ul>

    </div>

    
    
    

    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-----------------------（完）-----------------------</div>
    
</div>
      
    </div>

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8/" rel="tag"># 操作使用</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/python_list_memory2/" rel="prev" title="Python 列表结构及内存分析">
      <i class="fa fa-chevron-left"></i> Python 列表结构及内存分析
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/python_metaclass/" rel="next" title="Python 元类">
      Python 元类 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量与注释"><span class="nav-text">变量与注释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数值与字符串"><span class="nav-text">数值与字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#容器类型"><span class="nav-text">容器类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分之流程控制"><span class="nav-text">分之流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#异常与错误处理"><span class="nav-text">异常与错误处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环与可迭代对象"><span class="nav-text">循环与可迭代对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#装饰器"><span class="nav-text">装饰器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录1-内置语法特性"><span class="nav-text">附录1-内置语法特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#附录2-内置库功能"><span class="nav-text">附录2-内置库功能</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="stolen"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">stolen</p>
  <div class="site-description" itemprop="description">一个热爱技术的Python开发者</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">70</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/stolenzc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;stolenzc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3333060672" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3333060672" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.stolenzc.com/" title="https:&#x2F;&#x2F;www.stolenzc.com" rel="noopener" target="_blank">个人网站</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tools.stolenzc.com/" title="https:&#x2F;&#x2F;tools.stolenzc.com" rel="noopener" target="_blank">静态工具</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://stolenzc.gitee.io/" title="https:&#x2F;&#x2F;stolenzc.gitee.io" rel="noopener" target="_blank">gitee主页</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">stolen</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">219k</span>
</div>
  <div class="powered-by" style="display:none">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

</body>
</html>
